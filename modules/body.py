"""
This module outlines the 'body' object. These objects are the particles of the simulation.
Forces act on these objects, and they generate a field around them.
"""
from modules import vector
from modules import metrics
from modules import constants
from modules import colour

#import vector
#import metrics
#import constants
#import colour

import math,sys


class Body:
    def __init__(self, id, X0, V0, m=1, r=1, q=0, colour=colour.black, name=""):
        """
        Construct the body object.
        :X0: gives the intial position of the object
        :V0: gives the inital velocity of the object
        :m: - inertial and gravitational mass. Recall F=ma
        :r: - radius of the object, assume sphere
        :q: - charge of the object, used to give secondary force, independent of inertial mass.
        :id: - identification number for object.
        """

        if isinstance(X0, vector.Vector):
            self.X = X0
        else:
            self.X = vector.Vector(X0)
        if isinstance(V0, vector.Vector):
            self.V = V0
        else:
            self.V = vector.Vector(V0)

        self.id = id
        
        #self.X_prev = self.X
        #self.V_prev = self.V

        self.mass = m
        self.radius = r
        self.charge = q
        self.colour = colour
        
        self.trail_history = TrailHistory()
        self.anchor = False
        self.elasticity = 1
        self.can_collide = False
        self.drag = False
        
        self.name = name


    def __repr__(self):
        string = "body {{\n\t\"name\": {0}\n\tX: vector {1}\n\tV:vector {2}\n\tmass: {3}\n\tcharge: {4}\n\tradius: {5}\n\tcolour: colour {{{6}}}\n}}"\
            .format(self.name, self.X, self.V, self.mass, self.charge, self.radius, colour.get_rgb_str(self.colour))
        return string



    def get_name(self):
        name = ""
        if self.name != "":
            name = self.name
        else:
            name = "Body " + str(self.id)
        return name


    #####  FIELD GENERATED BY SELF
    
    def gravity_field(self, X, g_const, dist_error, laws=None):
        """
        Return the gravity field value at position X, as a result of body: self
        
        F = - G*m1*m2 / r^2  * r_unit  ==>  C = - G*m/r^2  * r_unit
        if r_unit is not unit vector, then take r^3 instead of r^2
        """
        
        return - g_const * self.mass * self.inverse_law(X,dist_error, laws)
    
    
    def electric_field(self, X, e_const, dist_error, laws=None):
        """
        Return the gravity field value at position X, as a result of body: self
            
        Like with gravitational field, V = E * q / r^2  * r_unit
        """
        return e_const * self.charge * self.inverse_law(X,dist_error, laws)


    def inverse_law(self, X, dist_error, laws=None):
        val = 0
        calc = True
        if laws != None:
            if laws[0] != 2 or laws[1] != 2:
                calc = False
                val = metrics.general_inverse_n_law(self.X,X, dist_error, laws[0], laws[1])
        if calc:
            val = metrics.inverse_square_law(self.X,X, dist_error)
        return val



    #####  GENERAL FORCES
    
    #Dont't re-include electric/grav forces, they are now computed in universe module.
    """
    def gravity_force(self, uni:universe.Universe):
        ###
        Find gravity force at time t, in universe uni
        
        F = mC, where C is the gravitational field.
        ###
        return self.mass * uni.net_gravity_field(self.id)
    
    
    def electric_force(self, uni:universe.Universe):
        ###
        Find electric force at time t.
        ###
        return self.charge * uni.net_electric_field(self.id)
    """
    
    def resistance_force(self, vel:vector.Vector, R_const, laws=None, viscous=True):
        """
        v^2 ==> viscous fluid, v^1 ==> non-viscous
        """
        # F = -R*A*v^2
        v = 1
        if viscous:
            v = metrics.metric_norm(vel, laws[1])
            #try:
            #
            #except OverflowError:
            #    print("Float Overflow Error occured while calculating vector normal in 'resistance_force' function.")
            #    v = sys.maxsize
        
        area = self.radius * self.radius * math.pi
        return  - R_const * area * v * vel




    def toggle_anchor(self):
        self.anchor = not self.anchor


    """
    def lorentz_factor(self, c:float):
        # get the lorentz factor for self
        # y = 1/sqrt(1- (v.v)/c^2)
        # c is the maximum speed for light.

        return 1/math.sqrt(1- vector.Vector.inner_product(self.V, self.V)/c^2)
        """ #not used, and update to use generalised euclidean norm.




    ####  general properties

    def get_coeff_restitution(self, other):
        """
        Look at the following for more information.
        https://en.wikipedia.org/wiki/Coefficient_of_restitution
        
        Model elasticity coefficent as K2 = eA*eB * K1 ==> r= sqrt(eA,eB)
        Where A self, B other
        """

        r = math.sqrt(self.elasticity * other.elasticity)
        return r





######    Object trails
######


class TrailHistory:
    """
    Variation of a Queue, queue on the head and dequeue off the tail.
    """
    def __init__(self):
        self.head = None
        self.tail = None
        self.skip_num = 0
        self.max_num = 0
        self.num = 0
        self.colour = colour.white

    def add_new_history(self, x:vector.Vector):
        new_node = Node(x)
        if self.head == None:
            self.tail = new_node
        else:
            self.head.next = new_node
        self.head = new_node
        self.num += 1

    def add_history(self, x:vector.Vector):
        #print("there")
        if self.max_num != 0:
            self.add_new_history(x)
            #print("here")
            if self.max_num > 0 and self.num > self.max_num:
                self.pop_history()

    def pop_history(self):
        if self.head == None:
            return None
        else:
            p = self.tail
            if self.head == self.tail:
                self.head = None
            self.tail = p.next
            self.num -= 1
            return p.value

    def get_history(self):
        #input()
        length = self.num
        N = length
        
        n = self.skip_num + 1
        if n > 0:
            N = math.ceil(N / n)
        points = [None] * N

        p = self.tail
        
        #print("N",N, "n", n)
        n = 0

        i = 0
        while i < N and p != None:
            if n <= 0:
                n = self.skip_num
                points[i] = p.value
                i += 1
            else:
                n -= 1
            #print("here")
            #print(p.value)
            p = p.next
    
        #print(self)
        #print(points)
        return points



    def __repr__(self):
        string = ""
        if self.tail == None:
            pass
        else:
            p = self.tail
            string += str(p.value)
            p = p.next
            while p != None:
                string += ", " +str(p.value)
                p = p.next
        return string



class Node:
    def __init__(self, val):
        self.value = val
        self.next = None

if __name__ == "__main__":
    pass


