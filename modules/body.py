"""
This module outlines the 'body' object. These objects are the particles of the simulation.
Forces act on these objects, and they generate a field around them.
"""
from modules import vector
from modules import metrics
from modules import constants
from modules import colour

#import vector
#import metrics
#import constants
#import colour

import math


class Body:
    def __init__(self, id, X0, V0, m=1, r=1, q=0, colour=colour.black, name=""):
        """
        Construct the body object.
        :X0: gives the intial position of the object
        :V0: gives the inital velocity of the object
        :m: - inertial and gravitational mass. Recall F=ma
        :r: - radius of the object, assume sphere
        :q: - charge of the object, used to give secondary force, independent of inertial mass.
        :id: - identification number for object.
        """

        if isinstance(X0, vector.Vector):
            self.X = X0
        else:
            self.X = vector.Vector(X0)
        if isinstance(V0, vector.Vector):
            self.V = V0
        else:
            self.V = vector.Vector(V0)

        self.X_prev = self.X
        self.V_prev = self.V

        self.mass = m
        self.radius = r
        self.charge = q
        self.id = id
        self.colour = colour
        
        self.anchor = False

        self.name = name


    def __repr__(self):
        string = "body {{\n\t\"name\": {0}\n\tX: vector {1}\n\tV:vector {2}\n\tmass: {3}\n\tcharge: {4}\n\tradius: {5}\n\tcolour: colour {{{6}}}\n}}"\
            .format(self.name, self.X, self.V, self.mass, self.charge, self.radius, colour.get_rgb_str(self.colour))
        return string


    #####  FIELD GENERATED BY SELF
    
    def gravity_field(self, X, dist_error, laws=None):
        """
        Return the gravity field value at position X, as a result of body: self
        
        F = - G*m1*m2 / r^2  * r_unit  ==>  C = - G*m/r^2  * r_unit
        if r_unit is not unit vector, then take r^3 instead of r^2
        """
        
        return - constants.G_const * self.mass * self.inverse_law(X,dist_error, laws)
    
    
    def electric_field(self, X, dist_error, laws=None):
        """
        Return the gravity field value at position X, as a result of body: self
            
        Like with gravitational field, V = E * q / r^2  * r_unit
        """
        return constants.E_const * self.charge * self.inverse_law(X,dist_error, laws)


    def inverse_law(self, X, dist_error, laws=None):
        val = 0
        calc = True
        if laws != None:
            if laws[0] != 2 or laws[1] != 2:
                calc = False
                val = metrics.general_inverse_n_law(self.X,X, dist_error, laws[0], laws[1])
        if calc:
            val = metrics.inverse_square_law(self.X,X, dist_error)
        return val



    #####  GENERAL FORCES
    
    #Dont't re-include electric/grav forces, they are now computed in universe module.
    """
    def gravity_force(self, uni:universe.Universe):
        ###
        Find gravity force at time t, in universe uni
        
        F = mC, where C is the gravitational field.
        ###
        return self.mass * uni.net_gravity_field(self.id)
    
    
    def electric_force(self, uni:universe.Universe):
        ###
        Find electric force at time t.
        ###
        return self.charge * uni.net_electric_field(self.id)
    """
    
    def resistance_force(self, vel:vector.Vector, laws=None):
        # F = -R*A*v^2
        v = 0
        calc = True
        if laws != None:
            if laws[1] != 2:
                v = metrics.metric_norm(vel, laws[1])
                calc = False
        if calc:
            v = vel.norm()
        area = self.radius * self.radius * math.pi
        return  - R_const * area * v * vel




    def toggle_anchor(self):
        self.anchor = not self.anchor


    """
    def lorentz_factor(self, c:float):
        # get the lorentz factor for self
        # y = 1/sqrt(1- (v.v)/c^2)
        # c is the maximum speed for light.

        return 1/math.sqrt(1- vector.Vector.inner_product(self.V, self.V)/c^2)
        """ #not used, and update to use generalised euclidean norm.




if __name__ == "__main__":
    pass


